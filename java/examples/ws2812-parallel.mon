# Script: WS2812 Parallel
# Group: WS2812
#
# Monitor script for ws2812_parallel example.
# To be executed on PIO 0, SM 0.
# Output is fed to GPIO 0.

# Make a full reset of the emulator.
reset

# We loosely follow the initialization sequence as shown in:
# https://github.com/raspberrypi/pico-examples
# /blob/master/pio/ws2812/generated/ws2812.pio.h
#
# This example uses timing T1=2, T2=5, T3=3.
# Note that, according to the discussion in
# https://github.com/raspberrypi/pico-feedback/issues/121,
# T1=T2=T3=2 may be a better choice.

# Configure Wrap.
wrap --pio=0 --sm=0 --wrap=3 --target=0

# Configure Side Set Count.
side-set --pio=0 --sm=0 --count=0 --opt=false

# The code.
# .wrap_target
enter -a 0 -v 0x6020 # out x, 32
enter -a 1 -v 0xa10b # mov pins, !null [1]
enter -a 2 -v 0xa401 # mov pins, x     [4]
enter -a 3 -v 0xa103 # mov pins, null  [1]
# .wrap

# Just for convience and verification, list the program that
# we just entered, as viewed by PIO 0, SM 0.
unassemble --pio=0 --sm=0 --address=0 --count=4

########
# Init program (analoguous to ws2812_program_init() in ws2812.pio.h as
# created by pioasm).
########

# Connect any of the GPIOs with PIO 0.  In this example,
# we choose GPIO 0-3.
gpio --pio=0 --gpio=0 --init   # tell GPIO0 to connect to PIO0
gpio --pio=0 --gpio=1 --init   # tell GPIO1 to connect to PIO0
gpio --pio=0 --gpio=2 --init   # tell GPIO2 to connect to PIO0
gpio --pio=0 --gpio=3 --init   # tell GPIO3 to connect to PIO0

# Set consecutive pindirs, again 4 GPIOs, base=0.
gpio --pio=0 --gpio=0 --enable # set direction out
gpio --pio=0 --gpio=1 --enable # set direction out
gpio --pio=0 --gpio=2 --enable # set direction out
gpio --pio=0 --gpio=3 --enable # set direction out

# SM Config Set Out Shift(right, autopull, threshold=32)
fifo --pio=0 --sm=0 --tx --shift-right
fifo --pio=0 --sm=0 --tx --auto=true
fifo --pio=0 --sm=0 --tx --threshold=32

# SM Config Set Out Pins(base=0, count=4).
pinctrl --pio=0 --sm=0 --out-base=0 --out-count=4

# SM Config Set Set Pins(base=0, count=4).
pinctrl --pio=0 --sm=0 --set-base=0 --set-count=4

# Configure FIFO join: Join TX.
fifo --pio=0 --sm=0 --join --tx

# Configure Clock Divider, here as 1.0 (maximum speed).
# We choose maximum speed since we do not want to see gaps when
# tracing the code.
clock --pio=0 --sm=0 --divider=1.0

########
# Initialize SM (analoguous to function pio_sm_init() in Pico C SDK).
########

# Disable state machine 0 of PIO 0 while executing the following
# commands.
sm --pio=0 --sm=0 --enable=false

# Clear FIFOs.
fifo --pio=0 --sm=0 --clear

# Clear FIFO debug flags.
fifo --pio=0 --sm=0 --clear-tx-stall
fifo --pio=0 --sm=0 --clear-tx-over
fifo --pio=0 --sm=0 --clear-rx-under
fifo --pio=0 --sm=0 --clear-rx-stall

# Restart SM.
sm --pio=0 --sm=0 --restart

# Restart clock.
clock --pio=0 --sm=0 --restart

# Set instruction pointer (PC) to address 0.
registers --address=0

########
# End of SM initialization.
########

# Enable state machine 0 of PIO 0 to execute the program.
sm --pio=0 --sm=0 --enable=true

########
# End of program initialization.
# Next, we feed in example data.
########

# Put example values into FIFO.  Since we have configured only
# GPIOs 0â€¦3, only the lowest 4 bits per FIFO word (=last hex digit)
# are relevant.
fifo --enqueue --tx --value 0x0000000a
fifo --enqueue --tx --value 0x00000005
fifo --enqueue --tx --value 0x00000001
fifo --enqueue --tx --value 0x0000000f
fifo --enqueue --tx --value 0x00000002
fifo --enqueue --tx --value 0x0000000e

# Done.
quit
